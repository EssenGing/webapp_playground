<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>書いて答えてモンスターをたおせ！</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700;800&display=swap" rel="stylesheet">
    <style>
        /* Basic styles for preventing scroll and setting font */
        html, body {
            width: 100%;
            /* remove height and overflow to allow scrolling on small screens */
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%; /* Prevent font size adjustment on iOS */
        }
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: manipulation; /* Disable double-tap to zoom */
        }
        /* 3D button effect styles */
        .btn-3d {
            transition: all 0.1s ease-out;
            box-shadow: 0 6px 0 #a3a3a3;
        }
        .btn-3d:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #a3a3a3;
        }
        .btn-3d:disabled {
            transform: translateY(2px);
            box-shadow: 0 4px 0 #9ca3af;
            background-color: #d1d5db;
            cursor: not-allowed;
        }
        /* Animation keyframes */
        @keyframes spawn {
            0% { transform: scale(0.5) translateY(50px); opacity: 0; }
            70% { transform: scale(1.1) translateY(0); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .animate-spawn { animation: spawn 0.5s ease-out forwards; }
        @keyframes defeat {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(15deg); opacity: 0.5; }
            100% { transform: scale(0.1) rotate(-360deg); opacity: 0; }
        }
        .animate-defeat { animation: defeat 0.6s ease-in forwards; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        .animate-shake { animation: shake 0.3s ease-in-out; }
        @keyframes celebrate-text {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .animate-celebrate { animation: celebrate-text 1s ease-in-out infinite; }
        @keyframes gameover-text {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-2deg); }
            75% { transform: scale(1.05) rotate(2deg); }
        }
        .animate-gameover { animation: gameover-text 0.5s ease-in-out; }

        /* Utility class for canvas */
        .touch-none {
            touch-action: none;
        }
        /* Category tab styles */
        .category-tab {
            transition: all 0.2s ease-in-out;
        }
        .category-tab.active {
            background-color: #06b6d4; /* cyan-500 */
            color: white;
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="bg-yellow-50 text-gray-800 flex items-center justify-center min-h-screen">
    <div id="app-container" class="w-full max-w-5xl mx-auto p-2 sm:p-4 text-center">

        <!-- サウンドオン/オフボタン -->
        <button id="mute-button" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-slate-400 hover:text-slate-600 z-10 p-2 rounded-full hover:bg-slate-200 transition">
            <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>
            <svg id="sound-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        </button>

        <!-- Deck Selection Screen -->
        <div id="deck-selection-screen" class="space-y-4 sm:space-y-6">
            <h1 class="text-3xl sm:text-5xl font-extrabold text-amber-600">書いて答えて<br>モンスターをたおせ！</h1>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg">
                <h2 class="text-xl sm:text-3xl font-bold mb-4 sm:mb-6">デッキをえらんでね</h2>
                <div id="deck-category-tabs" class="flex flex-wrap justify-center gap-2 mb-6"></div>
                <div id="deck-list" class="space-y-4 mb-6 max-h-60 sm:max-h-72 overflow-y-auto"></div>
                <button id="new-deck-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-5 sm:py-4 sm:px-6 w-full rounded-lg text-lg sm:text-2xl btn-3d">+ あたらしいデッキをつくる</button>
                <p class="text-xs sm:text-sm text-gray-500 mt-4 sm:mt-6">効果音：OtoLogic</p>
            </div>
        </div>

        <!-- Deck Editor Screen -->
        <div id="deck-editor-screen" class="hidden space-y-4">
            <h2 class="text-2xl sm:text-4xl font-bold text-amber-600">デッキのへんしゅう</h2>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg text-left">
                <div class="mb-4 sm:mb-6">
                    <label for="deck-name" class="font-bold text-lg sm:text-xl">デッキのなまえ</label>
                    <input type="text" id="deck-name" class="w-full text-lg sm:text-xl p-2 sm:p-3 border rounded mt-2" placeholder="例：かんじテスト">
                </div>
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-bold text-lg sm:text-xl">もんだいリスト</h3>
                </div>
                <div id="questions-list" class="space-y-2 mb-4 max-h-48 sm:max-h-60 overflow-y-auto p-2 sm:p-4 bg-gray-50 rounded min-h-[100px]"></div>
                <div class="border-t pt-4 sm:pt-6">
                    <h3 class="font-bold text-lg sm:text-xl mb-4">あたらしいもんだい</h3>
                    <div class="mb-4">
                         <label for="new-question" class="text-base sm:text-lg">もんだい</label>
                         <textarea id="new-question" rows="2" class="w-full p-2 sm:p-3 border rounded mt-1 text-base sm:text-lg" placeholder="例：日本の首都は？"></textarea>
                    </div>
                    <div class="mb-4">
                        <label for="new-answer" class="text-base sm:text-lg">こたえ</label>
                        <input type="text" id="new-answer" class="w-full p-2 sm:p-3 border rounded mt-1 text-base sm:text-lg" placeholder="例：東京">
                    </div>
                    <button id="add-question-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 rounded-lg btn-3d text-lg sm:text-xl">もんだいをついか</button>
                </div>
            </div>
             <div class="grid grid-cols-2 gap-4 sm:gap-6 mt-4 sm:mt-6">
                 <button id="save-deck-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">ほぞん</button>
                 <button id="back-to-selection-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">もどる</button>
            </div>
        </div>

        <!-- Number of Questions Selection Screen -->
        <div id="setup-screen" class="hidden space-y-4 sm:space-y-6">
            <h1 id="setup-title" class="text-2xl sm:text-4xl font-extrabold text-amber-600"></h1>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg">
                <h2 class="text-xl sm:text-3xl font-bold mb-6">なん体 たおす？</h2>
                <div id="question-count-buttons" class="grid grid-cols-2 lg:grid-cols-4 gap-4"></div>
                <div id="setup-info-area"></div>
                 <button id="back-to-decks-btn" class="mt-6 w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">デッキをえらびなおす</button>
            </div>
        </div>

        <!-- Main Game Screen -->
        <div id="main-screen" class="hidden">
            <!-- Adjusted paddings, margins, heights, and font sizes for better mobile view -->
            <div class="bg-white p-3 sm:p-6 rounded-2xl shadow-lg relative">
                <!-- NEW: Top section layout updated to prevent button overlap -->
                <div class="flex justify-between items-start gap-4 mb-3">
                    <!-- Left part with title, counter, timer -->
                    <div class="flex-1">
                        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3">
                            <h2 id="monster-title" class="text-lg sm:text-2xl md:text-3xl font-bold text-amber-600 order-2 sm:order-1 mt-2 sm:mt-0"></h2>
                            <p id="counter" class="text-sm sm:text-xl font-bold bg-gray-200 px-3 py-1 sm:px-5 sm:py-2 rounded-full order-1 sm:order-2 self-end sm:self-center"></p>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-3 sm:h-4">
                            <div id="timer-bar" class="bg-gradient-to-r from-yellow-400 to-red-500 h-3 sm:h-4 rounded-full" style="width: 100%; transition: width 1s linear;"></div>
                        </div>
                    </div>
                    <!-- Right part with buttons -->
                    <div id="game-buttons" class="flex flex-col space-y-3">
                        <button id="correct-btn" class="bg-green-500 hover:bg-green-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">せいかい！</button>
                        <button id="retry-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">解き直し</button>
                        <button id="next-btn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">つぎへ</button>
                    </div>
                </div>

                <div id="lives-area" class="flex justify-center gap-2 sm:gap-3 text-2xl sm:text-3xl mb-3"></div>
                <div class="bg-gray-100 p-2 sm:p-4 rounded-lg my-3 sm:my-4 min-h-[80px] sm:min-h-[120px] flex flex-col justify-center">
                    <div id="question-display" class="text-xl sm:text-3xl font-bold"></div>
                </div>

                <!-- UPDATED: Monster area height for responsive monster size -->
                <div id="monster-area" class="h-36 sm:h-48 flex items-center justify-center"></div>

                <div class="my-3 sm:my-4 relative">
                    <label class="font-bold text-left block mb-2 text-gray-600 text-base sm:text-lg">こたえをかいてみよう！</label>
                    <canvas id="handwriting-canvas" class="bg-white border-2 border-gray-300 rounded-lg w-full h-36 sm:h-56 cursor-crosshair touch-none"></canvas>
                    <button id="clear-canvas-btn" class="mt-3 w-full sm:w-1/2 mx-auto bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 sm:py-3 rounded-lg btn-3d text-base sm:text-lg">けす</button>
                </div>
            </div>
        </div>

        <!-- Clear Screen -->
        <div id="clear-screen" class="hidden">
            <canvas id="confetti-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
            <div class="bg-white p-6 sm:p-12 rounded-2xl shadow-2xl space-y-4 sm:space-y-6">
                <h1 class="text-3xl sm:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 animate-celebrate">ぜんぶ やっつけた！<br>おめでとう！</h1>
                <p class="text-7xl sm:text-9xl">🏆✨🎉</p>
                <div id="clear-results-area" class="text-left max-h-40 sm:max-h-60 overflow-y-auto bg-gray-50 p-4 sm:p-6 rounded-lg border"></div>
                <button class="restart-btn bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-3 px-8 sm:py-5 sm:px-10 rounded-lg text-xl sm:text-3xl btn-3d">もういっかい</button>
                <button id="create-incorrect-deck-clear-btn" class="mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d hidden">まちがえた問題でデッキ作成</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameover-screen" class="hidden">
            <div class="bg-gray-800 p-6 sm:p-12 rounded-2xl shadow-2xl space-y-4 sm:space-y-6 text-white">
                <h1 class="text-3xl sm:text-6xl font-extrabold text-red-500 animate-gameover">ゲームオーバー</h1>
                <p class="text-7xl sm:text-9xl">😭</p>
                <p class="text-lg sm:text-2xl">ざんねん…<br>またちょうせんしてね！</p>
                <div id="gameover-results-area" class="text-left max-h-40 sm:max-h-60 overflow-y-auto bg-gray-700 p-4 sm:p-6 rounded-lg border border-gray-600"></div>
                <button class="restart-btn bg-cyan-400 hover:bg-cyan-500 font-bold py-3 px-8 sm:py-5 sm:px-10 rounded-lg text-xl sm:text-3xl btn-3d">もういっかい</button>
                <button id="create-incorrect-deck-gameover-btn" class="mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d hidden">まちがえた問題でデッキ作成</button>
            </div>
        </div>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const screens = {
            deckSelection: document.getElementById('deck-selection-screen'),
            deckEditor: document.getElementById('deck-editor-screen'),
            setup: document.getElementById('setup-screen'),
            main: document.getElementById('main-screen'),
            clear: document.getElementById('clear-screen'),
            gameover: document.getElementById('gameover-screen'),
        };
        const deckCategoryTabs = document.getElementById('deck-category-tabs');
        const deckList = document.getElementById('deck-list');
        const newDeckBtn = document.getElementById('new-deck-btn');
        const deckNameInput = document.getElementById('deck-name');
        const questionsList = document.getElementById('questions-list');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const addQuestionBtn = document.getElementById('add-question-btn');
        const saveDeckBtn = document.getElementById('save-deck-btn');
        const backToSelectionBtn = document.getElementById('back-to-selection-btn');
        const setupTitle = document.getElementById('setup-title');
        const questionCountButtons = document.getElementById('question-count-buttons');
        const setupInfoArea = document.getElementById('setup-info-area');
        const backToDecksBtn = document.getElementById('back-to-decks-btn');
        const monsterTitle = document.getElementById('monster-title');
        const counter = document.getElementById('counter');
        const livesArea = document.getElementById('lives-area');
        const questionDisplay = document.getElementById('question-display');
        const monsterArea = document.getElementById('monster-area');
        const correctBtn = document.getElementById('correct-btn');
        const retryBtn = document.getElementById('retry-btn');
        const nextBtn = document.getElementById('next-btn');
        const handwritingCanvas = document.getElementById('handwriting-canvas');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const timerBar = document.getElementById('timer-bar');
        const muteButton = document.getElementById('mute-button');
        const soundOnIcon = document.getElementById('sound-on-icon');
        const soundOffIcon = document.getElementById('sound-off-icon');
        const createIncorrectDeckClearBtn = document.getElementById('create-incorrect-deck-clear-btn');
        const createIncorrectDeckGameoverBtn = document.getElementById('create-incorrect-deck-gameover-btn');


        // --- Default Decks ---
        const defaultDecks = [
            { name: '1年生のかんじ', category: '小学1年生', isDefault: true, questions: [{q:"山", a:"やま"}, {q:"川", a:"かわ"}, {q:"日", a:"ひ"}, {q:"月", a:"つき"}, {q:"木", a:"き"}] },
            { name: '2年生のかんじ', category: '小学2年生', isDefault: true, questions: [{q:"時", a:"とき"}, {q:"曜", a:"よう"}, {q:"週", a:"しゅう"}, {q:"春", a:"はる"}, {q:"夏", a:"なつ"}] },
            { name: '3年生のかんじ', category: '小学3年生', isDefault: true, questions: [{q:"都", a:"みやこ"}, {q:"県", a:"けん"}, {q:"市", a:"し"}, {q:"駅", a:"えき"}, {q:"店", a:"みせ"}] },
            { name: '4年生のかんじ', category: '小学4年生', isDefault: true, questions: [{q:"席", a:"せき"}, {q:"窓", a:"まど"}, {q:"軍", a:"ぐん"}, {q:"兵", a:"へい"}, {q:"臣", a:"しん"}] },
            { name: '5年生のかんじ', category: '小学5年生', isDefault: true, questions: [{q:"政", a:"せい"}, {q:"治", a:"じ"}, {q:"経", a:"けい"}, {q:"済", a:"ざい"}, {q:"歴", a:"れき"}] },
            { name: '6年生のかんじ', category: '小学6年生', isDefault: true, questions: [{q:"憲", a:"けん"}, {q:"法", a:"ほう"}, {q:"裁", a:"さい"}, {q:"判", a:"ばん"}, {q:"皇", a:"こう"}] },
            { name: 'どうぶつクイズ', category: 'その他', isDefault: true, questions: [{q:"世界で一番大きな動物は？", a:"シロナガスクジラ"}, {q:"首が一番長い動物は？", a:"キリン"}, {q:"鼻が長い動物は？", a:"ゾウ"}] },
        ];

        // --- Game State ---
        let allDecks = [];
        let currentDeckIndex = -1;
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let totalMonsters = 0;
        let defeatedMonsters = 0;
        let mistakes = 0;
        const MAX_MISTAKES = 3;
        let buttonsDisabled = false;
        let questionTimer = null;
        const TIME_LIMIT = 15;
        let selectedCategory = '小学1年生';
        let isMuted = false;
        let isPracticeMode = false;

        // --- Monster Data ---
        const MONSTERS = [
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhXNTz9LqGn-dTyacBt2n0JiCetzrkETOcF1neofXOypU1Zsb9afUTiMRm_G71xMuiuUH7WQKV8or5nhAARuDmTh7mp31wAh5mckUaUgTU3D_Hzz7hjDRsddYUWpXWrSdYrozHOj9heLMw/s170/monster01.png', emoji: '🌱' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhcGlFVplWQL65fn-lrtazTQL6rvrthKW6gtO2EeHeeNDEP2nJtpdUhDLzsT60ucQ25WT3KYA7Iw2p0Ji9Kn1RvnmTWhVqc8XbvTIFUu9P6zabvrX4r78cSjnxhhWELWL7piPX4rUeSdnI/s170/monster02.png', emoji: '👨‍' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEheSepCQGD9tU90G7ls1ufJ6LVwvFkjxrwiBzKumO7slJKxsf8QvrfMJjP2yj8ZSy5m5PM5KVh0vU8bVe7VtF36dMvoTNLDZXdzn5bR3mb-uwucFLKX-nEeMijuw9HiXOzC5IENJ5uKfFE/s170/monster03.png', emoji: '💪' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgrm2jo51T07UB6z83ceuz7AwQuTv3C_j-JfOmq7rRJptgH2xsSboxBLtVfhDwFO3R53Cl5nQiuE8aAkz0In702dv-Bp75S7cipUjtRwToNAEmGMZe1wNZPDachQ4p2eOWTAbq23kGvDno/s170/monster04.png', emoji: '👑' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgLcewHTO7BvACy7vf0mbeJo8gHXzznwUcJ_D615Cutcc_ix_t8UUYllNgqAE0QEe586HseeC3EJT_UZRhPzwpUmkdzU77PKEE9R_vSiD7qYtxMeDoemsGnKGzPPqDf3dmRLWcB_agvsUM/s170/monster05.png', emoji: '🕺' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwf_Xp6Betg2IhK6EqdWnfa4l6wV7rniHFbBE7rMTnqE28eaEmUP6ZgZZusF5TxH_R-8r9ENcekbLJGgNpy4XoZzeaV6nGNeQz5V0pKo105ReDxbyLnIxUyODtmqZvGaRZmWmESTGcDXM/s170/monster06.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj__yRJc635a99L5yetg9An8Y-Kgk055BufQNaWzz5p0MZX2JIYgSCLAgMrPmdxwl1nmW_yp59Wp1xNmm-raEjtYypJWsGDgQCcMKvAmWEkggPj9Di_pcF4yBoLb_FomQeXsq04-PtQbGM/s170/monster07.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGlhVDUtrBH4pfZmQmxvqY6PhZ-oKyejic_4guGF0i8gBZvZKITDwX1U8Frl1jSgxJ1j3BwjpI2MIgV40rqT9e5-wfVNd_1Us-bA5FnCuytfthrrDLGHSaSjn8l9Ik66JA8-Wg-YqQOQA/s800/monster08.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlGJd95yeHf7v5wPzLg4-lyxAI7yPHY4OzqxEdLY_Lf7DA3MvFsgh4SeUN2FNjg4juzBWIcFUNYGHOCIh3HTLAunpF4J-EpbRRkyhliav43vl4eyY6-ENhHnGPLmrc-OkwTRRcxa6m4cg/s170/monster09.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjpni__YcXjSExJ6M74waXyzQKDw0zMwi0SZ0yl-0PAPALq2DO4sKlLcfR0Io8fkyFRRhzLPnp2NftJrthjbnmtSmJVoJNQ5pjHFM_zeYNmJsgYJIgVkzHFkgyMHlhr3uPt-ZZEqAysYCc/s170/monster10.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhdW2bw5XFelBMMNMSx4_PST670AxRputfVYU_24fkGYmNeXerrd48CYIgE70vrT711Lwa5Xlgk1DqRSGjxfTZgpq26ky_TV5BazG_rhuMGufQgFFTBJE30qt04EHrTMRe2FqemO0Bk-bM/s170/monster11.png', emoji: '👹' },
            { name: 'モンスター', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg_aBArC2jvlxaDm_rW1HV2niXtxb9MAhuwFIZSIvGrQDAEci0DQBimJKE56oxhb49c2EiDaf16YNWVlUIw_OBcdbltm4JN0DP2CazcRJqsdNnAs4gxK2wSvTC6x8qkcqoN4OwQ2tVy7KI/s170/monster12.png', emoji: '👹' },
        ];
        const BOSS_MONSTER = { name: 'ドラゴン', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhWsvL0brkhZn9zU4BpyeOuPORRguZz4iPTopr4phHynEW0DATC9W5j11fWGDlghx_Eysn_5gGSLuBYybC28GRYzsPZB_qpNjFU8qMGpgL_fEi5iUfZv4GnEn_v-sI80WTqOPbSqrg1-3c/s180-c/fantasy_dragon.png', emoji: '🐉' };

        // --- Canvas State ---
        let canvasCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // --- Sound Effects ---
        function playSound(type) {
            if (isMuted) return;
            const sound = new Audio(type === 'correct' ? '../sounds/correct.mp3' : '../sounds/incorrect.mp3');
            sound.play().catch(e => console.error(`Error playing ${type} sound:`, e));
        }

        // --- Screen Management ---
        function showScreen(screenId) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            screens[screenId].classList.remove('hidden');
        }

        // --- Deck Management ---
        function loadAndCombineDecks() {
            const userDecks = JSON.parse(localStorage.getItem('monsterDecks')) || [];
            allDecks = [...defaultDecks, ...userDecks];
        }

        function saveUserDecks() {
            const userDecks = allDecks.filter(deck => !deck.isDefault);
            localStorage.setItem('monsterDecks', JSON.stringify(userDecks));
        }

        function renderDeckSelectionScreen() {
            const categories = ['小学1年生', '小学2年生', '小学3年生', '小学4年生', '小学5年生', '小学6年生', 'その他', 'じぶんのデッキ', 'まちがえた問題'];
            deckCategoryTabs.innerHTML = categories.map(cat => `
                <button data-category="${cat}" class="category-tab px-3 py-2 text-sm sm:text-base sm:px-4 rounded-lg font-bold bg-gray-200 hover:bg-cyan-300 ${selectedCategory === cat ? 'active' : ''}">
                    ${cat}
                </button>
            `).join('');

            let decksToDisplay;
            if (selectedCategory === 'じぶんのデッキ') {
                decksToDisplay = allDecks.filter(deck => !deck.isDefault && (deck.category === 'じぶんのデッキ' || typeof deck.category === 'undefined'));
            } else {
                decksToDisplay = allDecks.filter(deck => deck.category === selectedCategory);
            }

            deckList.innerHTML = '';
            if (decksToDisplay.length === 0) {
                let emptyMessage = 'このカテゴリのデッキはありません。';
                if (selectedCategory === 'じぶんのデッキ') {
                    emptyMessage = 'まだデッキがありません。<br>あたらしいデッキをつくろう！';
                } else if (selectedCategory === 'まちがえた問題') {
                    emptyMessage = 'まだまちがえた問題の<br>デッキはないよ';
                }
                deckList.innerHTML = `<p class="text-gray-500 text-base sm:text-xl">${emptyMessage}</p>`;
            } else {
                decksToDisplay.forEach(deck => {
                    const originalIndex = allDecks.indexOf(deck);
                    const deckEl = document.createElement('div');
                    deckEl.className = 'flex items-center gap-2 sm:gap-4';
                    deckEl.innerHTML = `
                        <button data-index="${originalIndex}" class="start-game-btn flex-grow bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-3 px-4 sm:py-4 sm:px-6 rounded-lg text-base sm:text-2xl btn-3d">${deck.name} (${deck.questions.length}もん)</button>
                        <button data-index="${originalIndex}" class="edit-deck-btn bg-yellow-500 hover:bg-yellow-600 text-white font-bold p-3 sm:p-4 rounded-lg btn-3d text-lg sm:text-2xl">✏️</button>
                        ${!deck.isDefault ? `<button data-index="${originalIndex}" class="delete-deck-btn bg-red-500 hover:bg-red-600 text-white font-bold p-3 sm:p-4 rounded-lg btn-3d text-lg sm:text-2xl">🗑️</button>` : ''}
                    `;
                    deckList.appendChild(deckEl);
                });
            }
        }

        // --- Deck Editor ---
        let tempQuestions = [];
        function openDeckEditor(index = -1) {
            if (index === -1) { // New Deck
                deckNameInput.value = '';
                tempQuestions = [];
                currentDeckIndex = -1;
            } else { // Edit Deck
                const deck = allDecks[index];
                if (deck.isDefault) {
                    deckNameInput.value = deck.name + 'のコピー';
                    currentDeckIndex = -1; // Treat as new deck
                } else {
                    deckNameInput.value = deck.name;
                    currentDeckIndex = index;
                }
                tempQuestions = JSON.parse(JSON.stringify(deck.questions));
            }
            renderQuestionsList();
            showScreen('deckEditor');
        }

        function renderQuestionsList() {
            questionsList.innerHTML = '';
            if(tempQuestions.length === 0) {
                questionsList.innerHTML = `<p class="text-gray-400 text-center p-4 text-base sm:text-lg">まだ問題がありません</p>`;
            }
            tempQuestions.forEach((q, index) => {
                const qEl = document.createElement('div');
                qEl.className = 'bg-white p-2 sm:p-3 border rounded flex justify-between items-center text-sm sm:text-lg';
                qEl.innerHTML = `
                    <span class="truncate pr-2"><b>Q:</b> ${q.q} / <b>A:</b> ${q.a}</span>
                    <button data-index="${index}" class="delete-question-btn bg-red-500 text-white rounded px-2 py-1 text-xs sm:text-base">さくじょ</button>
                `;
                questionsList.appendChild(qEl);
            });
        }

        // --- Game Setup ---
        function showSetupScreen(deckIndex) {
            currentDeckIndex = deckIndex;
            const deck = allDecks[deckIndex];
            setupTitle.textContent = `『${deck.name}』`;
            questionCountButtons.innerHTML = '';
            setupInfoArea.innerHTML = ''; // Clear info area

            if (deck.questions.length === 0) {
                questionCountButtons.innerHTML = `<p class="text-gray-500 col-span-2 lg:col-span-4 text-lg sm:text-xl">問題がありません。<br>デッキを編集してください。</p>`;
            } else {
                const counts = [5, 10];
                // Always show 5 and 10 options
                counts.forEach(count => {
                     questionCountButtons.innerHTML += `<button data-questions="${count}" class="question-btn bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-4 sm:py-5 px-4 rounded-lg text-lg sm:text-2xl btn-3d">${count}体</button>`;
                });

                // Add practice mode button
                questionCountButtons.innerHTML += `<button id="practice-mode-btn" class="col-span-2 lg:col-span-4 bg-red-400 hover:bg-red-500 text-white font-bold py-4 sm:py-5 px-4 rounded-lg text-lg sm:text-2xl btn-3d">れんしゅうモード</button>`;

                // Add warning message
                setupInfoArea.innerHTML = `<p class="text-xs sm:text-sm text-gray-500 mt-4">もんだいが少ないときは、同じもんだいが出ちゃうよ</p>`;
            }
            showScreen('setup');
        }

        // --- Core Game Logic ---
        function startGame(numQuestions) {
            totalMonsters = numQuestions;
            defeatedMonsters = 0;
            mistakes = 0;
            buttonsDisabled = false;

            if (isPracticeMode) {
                correctBtn.classList.add('hidden');
                retryBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
                livesArea.classList.add('hidden');
                timerBar.parentElement.classList.add('hidden');
                stopTimer();
            } else {
                correctBtn.classList.remove('hidden');
                retryBtn.classList.remove('hidden');
                nextBtn.classList.add('hidden');
                livesArea.classList.remove('hidden');
                timerBar.parentElement.classList.remove('hidden');
            }

            let deckQuestions = [...allDecks[currentDeckIndex].questions];
            currentQuestions = []; // Reset the questions list

            if (deckQuestions.length > 0) {
                // モンスターの数とライフポイント（間違えられる回数）の合計分の問題を用意します。
                // これにより、時間切れで間違えても常に新しい問題が出題されるようになります。
                const totalQuestionsToPrepare = numQuestions + MAX_MISTAKES;

                // 利用可能な問題をシャッフルします。
                let shuffledDeck = [...deckQuestions].sort(() => 0.5 - Math.random());

                // 必要な問題数がデッキの問題数より少ないか等しい場合
                if (totalQuestionsToPrepare <= shuffledDeck.length) {
                    // シャッフルされたデッキから必要な数だけ問題を取得します。
                    currentQuestions = shuffledDeck.slice(0, totalQuestionsToPrepare);
                } else {
                    // 必要な問題数がデッキの問題数より多い場合
                    // まず、シャッフルされたデッキのすべての問題を追加します。
                    currentQuestions = [...shuffledDeck];

                    // 不足している問題の数だけ、元のデッキからランダムに追加します（問題が重複します）。
                    const remainingQuestions = totalQuestionsToPrepare - shuffledDeck.length;
                    for (let i = 0; i < remainingQuestions; i++) {
                        const randomIndex = Math.floor(Math.random() * deckQuestions.length);
                        // 問題が重複する場合でも、各問題が独立したオブジェクトになるようにコピーを作成します。
                        currentQuestions.push(JSON.parse(JSON.stringify(deckQuestions[randomIndex])));
                    }
                }
            }

            currentQuestions.forEach(q => q.result = null);
            currentQuestionIndex = 0;

            updateLives();
            showScreen('main');
            initializeCanvas();
            spawnMonster();
            displayQuestion();
            updateCounter();
        }

        function nextTurn() {
            buttonsDisabled = false;
            updateCounter();
            spawnMonster();
            displayQuestion();
        }

        function drawPracticeAnswer() {
            if (!canvasCtx || currentQuestionIndex >= currentQuestions.length) return;
            const answer = currentQuestions[currentQuestionIndex].a;
            const canvas = handwritingCanvas;
            canvasCtx.save();
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.15)';

            // Dynamically calculate font size to fit the canvas
            const maxFontSize = canvas.height * 0.7;
            let fontSize = maxFontSize;
            canvasCtx.font = `800 ${fontSize}px '${getComputedStyle(document.body).fontFamily}'`;

            while(canvasCtx.measureText(answer).width > canvas.width * 0.9) {
                fontSize--;
                canvasCtx.font = `800 ${fontSize}px '${getComputedStyle(document.body).fontFamily}'`;
            }

            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';
            canvasCtx.fillText(answer, canvas.width / 2, canvas.height / 2);
            canvasCtx.restore();
        }

        function displayQuestion() {
            clearCanvas();
            // 用意した問題リストをすべて使い切ったらゲームクリア（予期せぬエラー防止）
            if (currentQuestionIndex >= currentQuestions.length) {
                 showClearScreen();
                return;
            }
            const qa = currentQuestions[currentQuestionIndex];
            questionDisplay.innerHTML = `<b>もんだい：</b> ${qa.q}`;
            buttonsDisabled = false;

            setTimeout(() => {
                if (isPracticeMode) {
                    initializeCanvas();
                    drawPracticeAnswer();
                }
            }, 100);

            if (!isPracticeMode) {
                startTimer();
            }
        }

        function spawnMonster() {
            monsterArea.innerHTML = '';
            let monster;
            // UPDATED: Monster size is now responsive and different for the boss
            let monsterSize;

            if (defeatedMonsters === totalMonsters - 1) {
                monster = BOSS_MONSTER;
                monsterTitle.textContent = `ついに${monster.name}があらわれた！`;
                // Boss monster size
                monsterSize = 'w-36 h-36 sm:w-48 sm:h-48';
            } else {
                monster = MONSTERS[Math.floor(Math.random() * MONSTERS.length)];
                monsterTitle.textContent = `${monster.name}があらわれた！`;
                // Regular monster size
                monsterSize = 'w-32 h-32 sm:w-44 sm:h-44';
            }

            const monsterEl = document.createElement('div');
            monsterEl.className = `${monsterSize} animate-spawn flex items-center justify-center`;

            const img = document.createElement('img');
            img.src = monster.image;
            img.className = 'w-full h-full object-contain';
            img.alt = monster.name;

            monsterEl.appendChild(img);
            monsterArea.appendChild(monsterEl);
        }

        function updateCounter() {
            counter.textContent = `のこり ${totalMonsters - defeatedMonsters} 体`;
        }

        function updateLives() {
            livesArea.innerHTML = '❤️'.repeat(MAX_MISTAKES - mistakes) + '🖤'.repeat(mistakes);
        }

        function handleCorrect() {
            stopTimer();
            if (buttonsDisabled || currentQuestionIndex >= currentQuestions.length) return;
            buttonsDisabled = true;
            playSound('correct');
            currentQuestions[currentQuestionIndex].result = 'correct';
            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-defeat');
            monsterEl?.addEventListener('animationend', () => {
                defeatedMonsters++;
                currentQuestionIndex++;
                if (defeatedMonsters >= totalMonsters) {
                    showClearScreen();
                } else {
                    nextTurn();
                }
            }, { once: true });
        }

        function handleRetry() {
            if (buttonsDisabled) return;
            playSound('incorrect');
            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-shake');
            monsterEl?.addEventListener('animationend', () => {
                monsterEl.classList.remove('animate-shake');
            }, { once: true });
            clearCanvas();
        }

        function handleTimeUp() {
            stopTimer();
            if (buttonsDisabled || currentQuestionIndex >= currentQuestions.length) return;
            buttonsDisabled = true;
            playSound('incorrect');

            currentQuestions[currentQuestionIndex].result = 'incorrect';
            mistakes++;
            updateLives();

            if (mistakes >= MAX_MISTAKES) {
                setTimeout(showGameOverScreen, 500);
                return;
            }

            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-shake');
            monsterEl?.addEventListener('animationend', () => {
                monsterEl.classList.remove('animate-shake');
                currentQuestionIndex++;
                // 間違えた場合は、次の問題を表示するだけ
                displayQuestion();
            }, { once: true });
        }

        // --- Timer ---
        function startTimer() {
            stopTimer();
            let timeLeft = TIME_LIMIT;
            timerBar.style.transition = 'width 1s linear';
            const updateTimerDisplay = () => {
                const percentage = (timeLeft / TIME_LIMIT) * 100;
                timerBar.style.width = `${percentage}%`;
            };
            updateTimerDisplay();
            questionTimer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                if (timeLeft < 0) {
                    handleTimeUp();
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(questionTimer);
            questionTimer = null;
            timerBar.style.transition = 'none';
        }

        // --- Canvas Drawing ---
        function initializeCanvas() {
            if(!canvasCtx) canvasCtx = handwritingCanvas.getContext('2d');
            const { width, height } = handwritingCanvas.getBoundingClientRect();
            handwritingCanvas.width = width;
            handwritingCanvas.height = height;
            canvasCtx.strokeStyle = '#374151';
            canvasCtx.lineWidth = Math.max(2, width / 100); // Responsive line width
            canvasCtx.lineJoin = 'round';
            canvasCtx.lineCap = 'round';
            clearCanvas();

            if (isPracticeMode && !screens.main.classList.contains('hidden')) {
                drawPracticeAnswer();
            }
        }

        function clearCanvas() {
            if(canvasCtx) {
                canvasCtx.clearRect(0, 0, handwritingCanvas.width, handwritingCanvas.height);
                if (isPracticeMode && !screens.main.classList.contains('hidden')) {
                    drawPracticeAnswer();
                }
            }
        }

        function getCoords(e) {
            const rect = handwritingCanvas.getBoundingClientRect();
            const touch = e.touches && e.touches[0];
            return [
                (touch ? touch.clientX : e.clientX) - rect.left,
                (touch ? touch.clientY : e.clientY) - rect.top
            ];
        }

        function startDrawing(e) { e.preventDefault(); isDrawing = true; [lastX, lastY] = getCoords(e); }
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const [currentX, currentY] = getCoords(e);
            canvasCtx.beginPath();
            canvasCtx.moveTo(lastX, lastY);
            canvasCtx.lineTo(currentX, currentY);
            canvasCtx.stroke();
            [lastX, lastY] = [currentX, currentY];
        }
        function stopDrawing() { isDrawing = false; }

        // --- Result Screens ---
        function renderResults(containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = `<h3 class="text-xl sm:text-2xl font-bold mb-4 text-center">もんだいとこたえ</h3>`;
            const list = document.createElement('ul');
            list.className = 'space-y-3';
            const answeredQuestions = currentQuestions.filter(q => q.result);
            answeredQuestions.forEach(qa => {
                const item = document.createElement('li');
                item.className = 'border-b border-gray-400 pb-2 text-sm sm:text-lg';
                let resultHTML = qa.result === 'correct'
                    ? `<span class="font-bold text-green-500 mr-2">[せいかい！]</span>`
                    : `<span class="font-bold text-red-500 mr-2">[ふせいかい…]</span>`;
                item.innerHTML = `<div>${resultHTML}<b>Q:</b> ${qa.q}</div><div class="pl-6"><b class="${containerId.includes('clear') ? 'text-blue-600' : 'text-cyan-400'}">A:</b> ${qa.a}</div>`;
                list.appendChild(item);
            });
            if (answeredQuestions.length === 0) { list.innerHTML = `<p class="text-gray-500">けっかがありません</p>`; }
            container.appendChild(list);
        }

        function showClearScreen() {
            stopTimer();
            showScreen('clear');

            const clearScreenTitle = document.querySelector('#clear-screen h1');
            const clearResultsArea = document.getElementById('clear-results-area');

            if (isPracticeMode) {
                clearScreenTitle.innerHTML = "練習おわり！<br>よくがんばったね！";
                clearScreenTitle.className = 'text-3xl sm:text-6xl font-extrabold text-cyan-500 animate-celebrate';
                clearResultsArea.innerHTML = `<p class="text-center text-lg sm:text-xl text-gray-600 p-4">たくさん練習して、<br>つぎは本番でたたかおう！</p>`;
            } else {
                clearScreenTitle.innerHTML = "ぜんぶ やっつけた！<br>おめでとう！";
                clearScreenTitle.className = 'text-3xl sm:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 animate-celebrate';
                renderResults('clear-results-area');
            }

            const incorrectQuestions = currentQuestions.filter(q => q.result !== 'correct');
            const originalDeck = allDecks[currentDeckIndex];
            // まちがえた問題があり、練習モードでなく、現在のデッキが「まちがえた問題」デッキでない場合のみボタンを表示
            if (incorrectQuestions.length > 0 && !isPracticeMode && originalDeck.category !== 'まちがえた問題') {
                const newDeckName = `${originalDeck.name}_まちがえた問題`;
                const incorrectDeckExists = allDecks.some(deck => deck.name === newDeckName && !deck.isDefault);

                if (incorrectDeckExists) {
                    createIncorrectDeckClearBtn.textContent = `まちがえた問題をデッキに追加`;
                } else {
                    createIncorrectDeckClearBtn.textContent = `まちがえた問題でデッキ作成`;
                }
                createIncorrectDeckClearBtn.disabled = false;
                createIncorrectDeckClearBtn.classList.remove('hidden');
            } else {
                createIncorrectDeckClearBtn.classList.add('hidden');
            }

            startConfetti();
        }

        function showGameOverScreen() {
            stopTimer();
            showScreen('gameover');
            renderResults('gameover-results-area');

            const incorrectQuestions = currentQuestions.filter(q => q.result !== 'correct');
            const originalDeck = allDecks[currentDeckIndex];
             // まちがえた問題があり、現在のデッキが「まちがえた問題」デッキでない場合のみボタンを表示
            if (incorrectQuestions.length > 0 && originalDeck.category !== 'まちがえた問題') {
                const newDeckName = `${originalDeck.name}_まちがえた問題`;
                const incorrectDeckExists = allDecks.some(deck => deck.name === newDeckName && !deck.isDefault);

                if (incorrectDeckExists) {
                    createIncorrectDeckGameoverBtn.textContent = `まちがえた問題をデッキに追加`;
                } else {
                    createIncorrectDeckGameoverBtn.textContent = `まちがえた問題でデッキ作成`;
                }
                createIncorrectDeckGameoverBtn.disabled = false;
                createIncorrectDeckGameoverBtn.classList.remove('hidden');
            } else {
                createIncorrectDeckGameoverBtn.classList.add('hidden');
            }
        }

        function createIncorrectDeck(buttonElement) {
            const incorrectQuestionsRaw = currentQuestions.filter(q => q.result !== 'correct');

            if (incorrectQuestionsRaw.length === 0) return;

            const uniqueIncorrectQuestions = Array.from(new Map(incorrectQuestionsRaw.map(item =>
                [item.q, { q: item.q, a: item.a }]
            )).values());

            if (uniqueIncorrectQuestions.length === 0) return;

            const originalDeck = allDecks[currentDeckIndex];
            const newDeckName = `${originalDeck.name}_まちがえた問題`;

            let incorrectDeck = allDecks.find(deck => deck.name === newDeckName && !deck.isDefault);

            if (incorrectDeck) {
                const existingQuestionsMap = new Map(incorrectDeck.questions.map(q => [q.q, q]));
                uniqueIncorrectQuestions.forEach(q => {
                    existingQuestionsMap.set(q.q, q);
                });
                incorrectDeck.questions = Array.from(existingQuestionsMap.values());
            } else {
                incorrectDeck = {
                    name: newDeckName,
                    questions: uniqueIncorrectQuestions,
                    isDefault: false,
                    category: 'まちがえた問題' // カテゴリを「まちがえた問題」に設定
                };
                allDecks.push(incorrectDeck);
            }

            saveUserDecks();
            buttonElement.textContent = '作成しました！';
            buttonElement.disabled = true;
        }


        // --- Event Listeners ---
        deckCategoryTabs.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.category) {
                selectedCategory = target.dataset.category;
                renderDeckSelectionScreen();
            }
        });

        deckList.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (!target) return;
            const index = parseInt(target.dataset.index);
            if (target.classList.contains('start-game-btn')) {
                if(allDecks[index].questions.length > 0) showSetupScreen(index);
                else alert('このデッキには問題がありません。編集してください。');
            } else if (target.classList.contains('edit-deck-btn')) {
                openDeckEditor(index);
            } else if (target.classList.contains('delete-deck-btn')) {
                if (confirm(`「${allDecks[index].name}」を本当に削除しますか？`)) {
                    allDecks.splice(index, 1);
                    saveUserDecks();
                    renderDeckSelectionScreen();
                }
            }
        });

        newDeckBtn.addEventListener('click', () => openDeckEditor(-1));

        addQuestionBtn.addEventListener('click', () => {
            const q = newQuestionInput.value.trim();
            const a = newAnswerInput.value.trim();
            if (q && a) {
                tempQuestions.push({ q, a });
                newQuestionInput.value = '';
                newAnswerInput.value = '';
                renderQuestionsList();
                newQuestionInput.focus();
            }
        });

        questionsList.addEventListener('click', e => {
            if (e.target.classList.contains('delete-question-btn')) {
                const index = parseInt(e.target.dataset.index);
                tempQuestions.splice(index, 1);
                renderQuestionsList();
            }
        });

        saveDeckBtn.addEventListener('click', () => {
            const name = deckNameInput.value.trim();
            if (!name) { alert('デッキのなまえをいれてください。'); return; }
            const newDeck = { name, questions: tempQuestions, isDefault: false, category: 'じぶんのデッキ' };
            if (currentDeckIndex === -1 || allDecks[currentDeckIndex]?.isDefault) {
                allDecks.push(newDeck);
            } else {
                allDecks[currentDeckIndex] = newDeck;
            }
            saveUserDecks();
            loadAndCombineDecks();
            selectedCategory = 'じぶんのデッキ';
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        });

        backToSelectionBtn.addEventListener('click', () => showScreen('deckSelection'));

        questionCountButtons.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (!target) return;

            if (target.id === 'practice-mode-btn') {
                isPracticeMode = true;
                const deck = allDecks[currentDeckIndex];
                const numQuestions = deck.questions.length >= 10 ? 10 : deck.questions.length;
                startGame(numQuestions);
            } else if (target.classList.contains('question-btn')) {
                isPracticeMode = false;
                startGame(parseInt(target.dataset.questions));
            }
        });

        backToDecksBtn.addEventListener('click', () => {
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        });

        correctBtn.addEventListener('click', handleCorrect);
        retryBtn.addEventListener('click', handleRetry);

        nextBtn.addEventListener('click', () => {
            if (buttonsDisabled) return;

            defeatedMonsters++;
            currentQuestionIndex++;

            if (defeatedMonsters >= totalMonsters) {
                showClearScreen();
            } else {
                nextTurn();
            }
        });

        document.querySelectorAll('.restart-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                renderDeckSelectionScreen();
                showScreen('deckSelection');
                stopConfetti();
            });
        });

        muteButton.addEventListener('click', () => {
            isMuted = !isMuted;
            soundOnIcon.classList.toggle('hidden', isMuted);
            soundOffIcon.classList.toggle('hidden', !isMuted);
        });

        // Canvas Event Listeners
        handwritingCanvas.addEventListener('mousedown', startDrawing);
        handwritingCanvas.addEventListener('mousemove', draw);
        handwritingCanvas.addEventListener('mouseup', stopDrawing);
        handwritingCanvas.addEventListener('mouseout', stopDrawing);
        handwritingCanvas.addEventListener('touchstart', startDrawing, { passive: false });
        handwritingCanvas.addEventListener('touchmove', draw, { passive: false });
        handwritingCanvas.addEventListener('touchend', stopDrawing);
        clearCanvasBtn.addEventListener('click', clearCanvas);
        window.addEventListener('resize', initializeCanvas);

        createIncorrectDeckClearBtn.addEventListener('click', () => createIncorrectDeck(createIncorrectDeckClearBtn));
        createIncorrectDeckGameoverBtn.addEventListener('click', () => createIncorrectDeck(createIncorrectDeckGameoverBtn));

        // --- App Initialization ---
        function initApp() {
            loadAndCombineDecks();
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        }
        initApp();

        // --- Confetti Effect ---
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        let confettiParticles = []; let animationFrameId;
        function startConfetti(){if(!canvas)return;canvas.width=window.innerWidth;canvas.height=window.innerHeight;confettiParticles=[];for(let i=0;i<100;i++){confettiParticles.push(createParticle())}renderConfetti()}
        function stopConfetti(){if(animationFrameId)cancelAnimationFrame(animationFrameId)}
        function createParticle(){const colors=['#f9a8d4','#f472b6','#86efac','#34d399','#67e8f9','#22d3ee','#fcd34d','#fbbf24'];return{x:Math.random()*canvas.width,y:Math.random()*canvas.height-canvas.height,size:Math.random()*8+5,color:colors[Math.floor(Math.random()*colors.length)],speed:Math.random()*3+2,angle:Math.random()*360,spin:Math.random()<.5?-1:1}}
        function renderConfetti(){if(!canvas)return;ctx.clearRect(0,0,canvas.width,canvas.height);confettiParticles.forEach((p,i)=>{p.y+=p.speed;p.angle+=p.spin*5;ctx.save();ctx.fillStyle=p.color;ctx.translate(p.x+p.size/2,p.y+p.size/2);ctx.rotate(p.angle*Math.PI/180);ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size);ctx.restore();if(p.y>canvas.height){confettiParticles[i]=createParticle();confettiParticles[i].y=-10}});animationFrameId=requestAnimationFrame(renderConfetti)}
    });
    </script>
</body>
</html>
