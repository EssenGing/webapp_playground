<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ›¸ã„ã¦ç­”ãˆã¦ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ãŸãŠã›ï¼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700;800&display=swap" rel="stylesheet">
    <style>
        /* Basic styles for preventing scroll and setting font */
        html, body {
            width: 100%;
            /* remove height and overflow to allow scrolling on small screens */
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%; /* Prevent font size adjustment on iOS */
        }
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: manipulation; /* Disable double-tap to zoom */
        }
        /* 3D button effect styles */
        .btn-3d {
            transition: all 0.1s ease-out;
            box-shadow: 0 6px 0 #a3a3a3;
        }
        .btn-3d:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #a3a3a3;
        }
        .btn-3d:disabled {
            transform: translateY(2px);
            box-shadow: 0 4px 0 #9ca3af;
            background-color: #d1d5db;
            cursor: not-allowed;
        }
        /* Animation keyframes */
        @keyframes spawn {
            0% { transform: scale(0.5) translateY(50px); opacity: 0; }
            70% { transform: scale(1.1) translateY(0); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .animate-spawn { animation: spawn 0.5s ease-out forwards; }
        @keyframes defeat {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(15deg); opacity: 0.5; }
            100% { transform: scale(0.1) rotate(-360deg); opacity: 0; }
        }
        .animate-defeat { animation: defeat 0.6s ease-in forwards; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        .animate-shake { animation: shake 0.3s ease-in-out; }
        @keyframes celebrate-text {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .animate-celebrate { animation: celebrate-text 1s ease-in-out infinite; }
        @keyframes gameover-text {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-2deg); }
            75% { transform: scale(1.05) rotate(2deg); }
        }
        .animate-gameover { animation: gameover-text 0.5s ease-in-out; }

        /* Utility class for canvas */
        .touch-none {
            touch-action: none;
        }
        /* Category tab styles */
        .category-tab {
            transition: all 0.2s ease-in-out;
        }
        .category-tab.active {
            background-color: #06b6d4; /* cyan-500 */
            color: white;
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="bg-yellow-50 text-gray-800 flex items-center justify-center min-h-screen">
    <div id="app-container" class="w-full max-w-5xl mx-auto p-2 sm:p-4 text-center">

        <!-- ã‚µã‚¦ãƒ³ãƒ‰ã‚ªãƒ³/ã‚ªãƒ•ãƒœã‚¿ãƒ³ -->
        <button id="mute-button" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-slate-400 hover:text-slate-600 z-10 p-2 rounded-full hover:bg-slate-200 transition">
            <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>
            <svg id="sound-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        </button>

        <!-- Deck Selection Screen -->
        <div id="deck-selection-screen" class="space-y-4 sm:space-y-6">
            <h1 class="text-3xl sm:text-5xl font-extrabold text-amber-600">æ›¸ã„ã¦ç­”ãˆã¦<br>ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ãŸãŠã›ï¼</h1>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg">
                <h2 class="text-xl sm:text-3xl font-bold mb-4 sm:mb-6">ãƒ‡ãƒƒã‚­ã‚’ãˆã‚‰ã‚“ã§ã­</h2>
                <div id="deck-category-tabs" class="flex flex-wrap justify-center gap-2 mb-6"></div>
                <div id="deck-list" class="space-y-4 mb-6 max-h-60 sm:max-h-72 overflow-y-auto"></div>
                <button id="new-deck-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-5 sm:py-4 sm:px-6 w-full rounded-lg text-lg sm:text-2xl btn-3d">+ ã‚ãŸã‚‰ã—ã„ãƒ‡ãƒƒã‚­ã‚’ã¤ãã‚‹</button>
                <p class="text-xs sm:text-sm text-gray-500 mt-4 sm:mt-6">åŠ¹æœéŸ³ï¼šOtoLogic</p>
            </div>
        </div>

        <!-- Deck Editor Screen -->
        <div id="deck-editor-screen" class="hidden space-y-4">
            <h2 class="text-2xl sm:text-4xl font-bold text-amber-600">ãƒ‡ãƒƒã‚­ã®ã¸ã‚“ã—ã‚…ã†</h2>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg text-left">
                <div class="mb-4 sm:mb-6">
                    <label for="deck-name" class="font-bold text-lg sm:text-xl">ãƒ‡ãƒƒã‚­ã®ãªã¾ãˆ</label>
                    <input type="text" id="deck-name" class="w-full text-lg sm:text-xl p-2 sm:p-3 border rounded mt-2" placeholder="ä¾‹ï¼šã‹ã‚“ã˜ãƒ†ã‚¹ãƒˆ">
                </div>
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-bold text-lg sm:text-xl">ã‚‚ã‚“ã ã„ãƒªã‚¹ãƒˆ</h3>
                </div>
                <div id="questions-list" class="space-y-2 mb-4 max-h-48 sm:max-h-60 overflow-y-auto p-2 sm:p-4 bg-gray-50 rounded min-h-[100px]"></div>
                <div class="border-t pt-4 sm:pt-6">
                    <h3 class="font-bold text-lg sm:text-xl mb-4">ã‚ãŸã‚‰ã—ã„ã‚‚ã‚“ã ã„</h3>
                    <div class="mb-4">
                         <label for="new-question" class="text-base sm:text-lg">ã‚‚ã‚“ã ã„</label>
                         <textarea id="new-question" rows="2" class="w-full p-2 sm:p-3 border rounded mt-1 text-base sm:text-lg" placeholder="ä¾‹ï¼šæ—¥æœ¬ã®é¦–éƒ½ã¯ï¼Ÿ"></textarea>
                    </div>
                    <div class="mb-4">
                        <label for="new-answer" class="text-base sm:text-lg">ã“ãŸãˆ</label>
                        <input type="text" id="new-answer" class="w-full p-2 sm:p-3 border rounded mt-1 text-base sm:text-lg" placeholder="ä¾‹ï¼šæ±äº¬">
                    </div>
                    <button id="add-question-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 rounded-lg btn-3d text-lg sm:text-xl">ã‚‚ã‚“ã ã„ã‚’ã¤ã„ã‹</button>
                </div>
            </div>
             <div class="grid grid-cols-2 gap-4 sm:gap-6 mt-4 sm:mt-6">
                 <button id="save-deck-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">ã»ãã‚“</button>
                 <button id="back-to-selection-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">ã‚‚ã©ã‚‹</button>
            </div>
        </div>

        <!-- Number of Questions Selection Screen -->
        <div id="setup-screen" class="hidden space-y-4 sm:space-y-6">
            <h1 id="setup-title" class="text-2xl sm:text-4xl font-extrabold text-amber-600"></h1>
            <div class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg">
                <h2 class="text-xl sm:text-3xl font-bold mb-6">ãªã‚“ä½“ ãŸãŠã™ï¼Ÿ</h2>
                <div id="question-count-buttons" class="grid grid-cols-2 lg:grid-cols-4 gap-4"></div>
                <div id="setup-info-area"></div>
                 <button id="back-to-decks-btn" class="mt-6 w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d">ãƒ‡ãƒƒã‚­ã‚’ãˆã‚‰ã³ãªãŠã™</button>
            </div>
        </div>

        <!-- Main Game Screen -->
        <div id="main-screen" class="hidden">
            <!-- Adjusted paddings, margins, heights, and font sizes for better mobile view -->
            <div class="bg-white p-3 sm:p-6 rounded-2xl shadow-lg relative">
                <!-- NEW: Top section layout updated to prevent button overlap -->
                <div class="flex justify-between items-start gap-4 mb-3">
                    <!-- Left part with title, counter, timer -->
                    <div class="flex-1">
                        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3">
                            <h2 id="monster-title" class="text-lg sm:text-2xl md:text-3xl font-bold text-amber-600 order-2 sm:order-1 mt-2 sm:mt-0"></h2>
                            <p id="counter" class="text-sm sm:text-xl font-bold bg-gray-200 px-3 py-1 sm:px-5 sm:py-2 rounded-full order-1 sm:order-2 self-end sm:self-center"></p>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-3 sm:h-4">
                            <div id="timer-bar" class="bg-gradient-to-r from-yellow-400 to-red-500 h-3 sm:h-4 rounded-full" style="width: 100%; transition: width 1s linear;"></div>
                        </div>
                    </div>
                    <!-- Right part with buttons -->
                    <div id="game-buttons" class="flex flex-col space-y-3">
                        <button id="correct-btn" class="bg-green-500 hover:bg-green-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">ã›ã„ã‹ã„ï¼</button>
                        <button id="retry-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">è§£ãç›´ã—</button>
                        <button id="next-btn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-extrabold py-2 px-4 sm:py-3 sm:px-5 rounded-xl text-base sm:text-xl btn-3d">ã¤ãã¸</button>
                    </div>
                </div>

                <div id="lives-area" class="flex justify-center gap-2 sm:gap-3 text-2xl sm:text-3xl mb-3"></div>
                <div class="bg-gray-100 p-2 sm:p-4 rounded-lg my-3 sm:my-4 min-h-[80px] sm:min-h-[120px] flex flex-col justify-center">
                    <div id="question-display" class="text-xl sm:text-3xl font-bold"></div>
                </div>

                <!-- UPDATED: Monster area height for responsive monster size -->
                <div id="monster-area" class="h-36 sm:h-48 flex items-center justify-center"></div>

                <div class="my-3 sm:my-4 relative">
                    <label class="font-bold text-left block mb-2 text-gray-600 text-base sm:text-lg">ã“ãŸãˆã‚’ã‹ã„ã¦ã¿ã‚ˆã†ï¼</label>
                    <canvas id="handwriting-canvas" class="bg-white border-2 border-gray-300 rounded-lg w-full h-36 sm:h-56 cursor-crosshair touch-none"></canvas>
                    <button id="clear-canvas-btn" class="mt-3 w-full sm:w-1/2 mx-auto bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 sm:py-3 rounded-lg btn-3d text-base sm:text-lg">ã‘ã™</button>
                </div>
            </div>
        </div>

        <!-- Clear Screen -->
        <div id="clear-screen" class="hidden">
            <canvas id="confetti-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
            <div class="bg-white p-6 sm:p-12 rounded-2xl shadow-2xl space-y-4 sm:space-y-6">
                <h1 class="text-3xl sm:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 animate-celebrate">ãœã‚“ã¶ ã‚„ã£ã¤ã‘ãŸï¼<br>ãŠã‚ã§ã¨ã†ï¼</h1>
                <p class="text-7xl sm:text-9xl">ğŸ†âœ¨ğŸ‰</p>
                <div id="clear-results-area" class="text-left max-h-40 sm:max-h-60 overflow-y-auto bg-gray-50 p-4 sm:p-6 rounded-lg border"></div>
                <button class="restart-btn bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-3 px-8 sm:py-5 sm:px-10 rounded-lg text-xl sm:text-3xl btn-3d">ã‚‚ã†ã„ã£ã‹ã„</button>
                <button id="create-incorrect-deck-clear-btn" class="mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d hidden">ã¾ã¡ãŒãˆãŸå•é¡Œã§ãƒ‡ãƒƒã‚­ä½œæˆ</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameover-screen" class="hidden">
            <div class="bg-gray-800 p-6 sm:p-12 rounded-2xl shadow-2xl space-y-4 sm:space-y-6 text-white">
                <h1 class="text-3xl sm:text-6xl font-extrabold text-red-500 animate-gameover">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
                <p class="text-7xl sm:text-9xl">ğŸ˜­</p>
                <p class="text-lg sm:text-2xl">ã–ã‚“ã­ã‚“â€¦<br>ã¾ãŸã¡ã‚‡ã†ã›ã‚“ã—ã¦ã­ï¼</p>
                <div id="gameover-results-area" class="text-left max-h-40 sm:max-h-60 overflow-y-auto bg-gray-700 p-4 sm:p-6 rounded-lg border border-gray-600"></div>
                <button class="restart-btn bg-cyan-400 hover:bg-cyan-500 font-bold py-3 px-8 sm:py-5 sm:px-10 rounded-lg text-xl sm:text-3xl btn-3d">ã‚‚ã†ã„ã£ã‹ã„</button>
                <button id="create-incorrect-deck-gameover-btn" class="mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 sm:py-4 rounded-lg text-lg sm:text-2xl btn-3d hidden">ã¾ã¡ãŒãˆãŸå•é¡Œã§ãƒ‡ãƒƒã‚­ä½œæˆ</button>
            </div>
        </div>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const screens = {
            deckSelection: document.getElementById('deck-selection-screen'),
            deckEditor: document.getElementById('deck-editor-screen'),
            setup: document.getElementById('setup-screen'),
            main: document.getElementById('main-screen'),
            clear: document.getElementById('clear-screen'),
            gameover: document.getElementById('gameover-screen'),
        };
        const deckCategoryTabs = document.getElementById('deck-category-tabs');
        const deckList = document.getElementById('deck-list');
        const newDeckBtn = document.getElementById('new-deck-btn');
        const deckNameInput = document.getElementById('deck-name');
        const questionsList = document.getElementById('questions-list');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const addQuestionBtn = document.getElementById('add-question-btn');
        const saveDeckBtn = document.getElementById('save-deck-btn');
        const backToSelectionBtn = document.getElementById('back-to-selection-btn');
        const setupTitle = document.getElementById('setup-title');
        const questionCountButtons = document.getElementById('question-count-buttons');
        const setupInfoArea = document.getElementById('setup-info-area');
        const backToDecksBtn = document.getElementById('back-to-decks-btn');
        const monsterTitle = document.getElementById('monster-title');
        const counter = document.getElementById('counter');
        const livesArea = document.getElementById('lives-area');
        const questionDisplay = document.getElementById('question-display');
        const monsterArea = document.getElementById('monster-area');
        const correctBtn = document.getElementById('correct-btn');
        const retryBtn = document.getElementById('retry-btn');
        const nextBtn = document.getElementById('next-btn');
        const handwritingCanvas = document.getElementById('handwriting-canvas');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const timerBar = document.getElementById('timer-bar');
        const muteButton = document.getElementById('mute-button');
        const soundOnIcon = document.getElementById('sound-on-icon');
        const soundOffIcon = document.getElementById('sound-off-icon');
        const createIncorrectDeckClearBtn = document.getElementById('create-incorrect-deck-clear-btn');
        const createIncorrectDeckGameoverBtn = document.getElementById('create-incorrect-deck-gameover-btn');


        // --- Default Decks ---
        const defaultDecks = [
            { name: '1å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦1å¹´ç”Ÿ', isDefault: true, questions: [{q:"å±±", a:"ã‚„ã¾"}, {q:"å·", a:"ã‹ã‚"}, {q:"æ—¥", a:"ã²"}, {q:"æœˆ", a:"ã¤ã"}, {q:"æœ¨", a:"ã"}] },
            { name: '2å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦2å¹´ç”Ÿ', isDefault: true, questions: [{q:"æ™‚", a:"ã¨ã"}, {q:"æ›œ", a:"ã‚ˆã†"}, {q:"é€±", a:"ã—ã‚…ã†"}, {q:"æ˜¥", a:"ã¯ã‚‹"}, {q:"å¤", a:"ãªã¤"}] },
            { name: '3å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦3å¹´ç”Ÿ', isDefault: true, questions: [{q:"éƒ½", a:"ã¿ã‚„ã“"}, {q:"çœŒ", a:"ã‘ã‚“"}, {q:"å¸‚", a:"ã—"}, {q:"é§…", a:"ãˆã"}, {q:"åº—", a:"ã¿ã›"}] },
            { name: '4å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦4å¹´ç”Ÿ', isDefault: true, questions: [{q:"å¸­", a:"ã›ã"}, {q:"çª“", a:"ã¾ã©"}, {q:"è»", a:"ãã‚“"}, {q:"å…µ", a:"ã¸ã„"}, {q:"è‡£", a:"ã—ã‚“"}] },
            { name: '5å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦5å¹´ç”Ÿ', isDefault: true, questions: [{q:"æ”¿", a:"ã›ã„"}, {q:"æ²»", a:"ã˜"}, {q:"çµŒ", a:"ã‘ã„"}, {q:"æ¸ˆ", a:"ã–ã„"}, {q:"æ­´", a:"ã‚Œã"}] },
            { name: '6å¹´ç”Ÿã®ã‹ã‚“ã˜', category: 'å°å­¦6å¹´ç”Ÿ', isDefault: true, questions: [{q:"æ†²", a:"ã‘ã‚“"}, {q:"æ³•", a:"ã»ã†"}, {q:"è£", a:"ã•ã„"}, {q:"åˆ¤", a:"ã°ã‚“"}, {q:"çš‡", a:"ã“ã†"}] },
            { name: 'ã©ã†ã¶ã¤ã‚¯ã‚¤ã‚º', category: 'ãã®ä»–', isDefault: true, questions: [{q:"ä¸–ç•Œã§ä¸€ç•ªå¤§ããªå‹•ç‰©ã¯ï¼Ÿ", a:"ã‚·ãƒ­ãƒŠã‚¬ã‚¹ã‚¯ã‚¸ãƒ©"}, {q:"é¦–ãŒä¸€ç•ªé•·ã„å‹•ç‰©ã¯ï¼Ÿ", a:"ã‚­ãƒªãƒ³"}, {q:"é¼»ãŒé•·ã„å‹•ç‰©ã¯ï¼Ÿ", a:"ã‚¾ã‚¦"}] },
        ];

        // --- Game State ---
        let allDecks = [];
        let currentDeckIndex = -1;
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let totalMonsters = 0;
        let defeatedMonsters = 0;
        let mistakes = 0;
        const MAX_MISTAKES = 3;
        let buttonsDisabled = false;
        let questionTimer = null;
        const TIME_LIMIT = 15;
        let selectedCategory = 'å°å­¦1å¹´ç”Ÿ';
        let isMuted = false;
        let isPracticeMode = false;

        // --- Monster Data ---
        const MONSTERS = [
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhXNTz9LqGn-dTyacBt2n0JiCetzrkETOcF1neofXOypU1Zsb9afUTiMRm_G71xMuiuUH7WQKV8or5nhAARuDmTh7mp31wAh5mckUaUgTU3D_Hzz7hjDRsddYUWpXWrSdYrozHOj9heLMw/s170/monster01.png', emoji: 'ğŸŒ±' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhcGlFVplWQL65fn-lrtazTQL6rvrthKW6gtO2EeHeeNDEP2nJtpdUhDLzsT60ucQ25WT3KYA7Iw2p0Ji9Kn1RvnmTWhVqc8XbvTIFUu9P6zabvrX4r78cSjnxhhWELWL7piPX4rUeSdnI/s170/monster02.png', emoji: 'ğŸ‘¨â€' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEheSepCQGD9tU90G7ls1ufJ6LVwvFkjxrwiBzKumO7slJKxsf8QvrfMJjP2yj8ZSy5m5PM5KVh0vU8bVe7VtF36dMvoTNLDZXdzn5bR3mb-uwucFLKX-nEeMijuw9HiXOzC5IENJ5uKfFE/s170/monster03.png', emoji: 'ğŸ’ª' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgrm2jo51T07UB6z83ceuz7AwQuTv3C_j-JfOmq7rRJptgH2xsSboxBLtVfhDwFO3R53Cl5nQiuE8aAkz0In702dv-Bp75S7cipUjtRwToNAEmGMZe1wNZPDachQ4p2eOWTAbq23kGvDno/s170/monster04.png', emoji: 'ğŸ‘‘' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgLcewHTO7BvACy7vf0mbeJo8gHXzznwUcJ_D615Cutcc_ix_t8UUYllNgqAE0QEe586HseeC3EJT_UZRhPzwpUmkdzU77PKEE9R_vSiD7qYtxMeDoemsGnKGzPPqDf3dmRLWcB_agvsUM/s170/monster05.png', emoji: 'ğŸ•º' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwf_Xp6Betg2IhK6EqdWnfa4l6wV7rniHFbBE7rMTnqE28eaEmUP6ZgZZusF5TxH_R-8r9ENcekbLJGgNpy4XoZzeaV6nGNeQz5V0pKo105ReDxbyLnIxUyODtmqZvGaRZmWmESTGcDXM/s170/monster06.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj__yRJc635a99L5yetg9An8Y-Kgk055BufQNaWzz5p0MZX2JIYgSCLAgMrPmdxwl1nmW_yp59Wp1xNmm-raEjtYypJWsGDgQCcMKvAmWEkggPj9Di_pcF4yBoLb_FomQeXsq04-PtQbGM/s170/monster07.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGlhVDUtrBH4pfZmQmxvqY6PhZ-oKyejic_4guGF0i8gBZvZKITDwX1U8Frl1jSgxJ1j3BwjpI2MIgV40rqT9e5-wfVNd_1Us-bA5FnCuytfthrrDLGHSaSjn8l9Ik66JA8-Wg-YqQOQA/s800/monster08.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlGJd95yeHf7v5wPzLg4-lyxAI7yPHY4OzqxEdLY_Lf7DA3MvFsgh4SeUN2FNjg4juzBWIcFUNYGHOCIh3HTLAunpF4J-EpbRRkyhliav43vl4eyY6-ENhHnGPLmrc-OkwTRRcxa6m4cg/s170/monster09.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjpni__YcXjSExJ6M74waXyzQKDw0zMwi0SZ0yl-0PAPALq2DO4sKlLcfR0Io8fkyFRRhzLPnp2NftJrthjbnmtSmJVoJNQ5pjHFM_zeYNmJsgYJIgVkzHFkgyMHlhr3uPt-ZZEqAysYCc/s170/monster10.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhdW2bw5XFelBMMNMSx4_PST670AxRputfVYU_24fkGYmNeXerrd48CYIgE70vrT711Lwa5Xlgk1DqRSGjxfTZgpq26ky_TV5BazG_rhuMGufQgFFTBJE30qt04EHrTMRe2FqemO0Bk-bM/s170/monster11.png', emoji: 'ğŸ‘¹' },
            { name: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg_aBArC2jvlxaDm_rW1HV2niXtxb9MAhuwFIZSIvGrQDAEci0DQBimJKE56oxhb49c2EiDaf16YNWVlUIw_OBcdbltm4JN0DP2CazcRJqsdNnAs4gxK2wSvTC6x8qkcqoN4OwQ2tVy7KI/s170/monster12.png', emoji: 'ğŸ‘¹' },
        ];
        const BOSS_MONSTER = { name: 'ãƒ‰ãƒ©ã‚´ãƒ³', image: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhWsvL0brkhZn9zU4BpyeOuPORRguZz4iPTopr4phHynEW0DATC9W5j11fWGDlghx_Eysn_5gGSLuBYybC28GRYzsPZB_qpNjFU8qMGpgL_fEi5iUfZv4GnEn_v-sI80WTqOPbSqrg1-3c/s180-c/fantasy_dragon.png', emoji: 'ğŸ‰' };

        // --- Canvas State ---
        let canvasCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // --- Sound Effects ---
        function playSound(type) {
            if (isMuted) return;
            const sound = new Audio(type === 'correct' ? '../sounds/correct.mp3' : '../sounds/incorrect.mp3');
            sound.play().catch(e => console.error(`Error playing ${type} sound:`, e));
        }

        // --- Screen Management ---
        function showScreen(screenId) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            screens[screenId].classList.remove('hidden');
        }

        // --- Deck Management ---
        function loadAndCombineDecks() {
            const userDecks = JSON.parse(localStorage.getItem('monsterDecks')) || [];
            allDecks = [...defaultDecks, ...userDecks];
        }

        function saveUserDecks() {
            const userDecks = allDecks.filter(deck => !deck.isDefault);
            localStorage.setItem('monsterDecks', JSON.stringify(userDecks));
        }

        function renderDeckSelectionScreen() {
            const categories = ['å°å­¦1å¹´ç”Ÿ', 'å°å­¦2å¹´ç”Ÿ', 'å°å­¦3å¹´ç”Ÿ', 'å°å­¦4å¹´ç”Ÿ', 'å°å­¦5å¹´ç”Ÿ', 'å°å­¦6å¹´ç”Ÿ', 'ãã®ä»–', 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­', 'ã¾ã¡ãŒãˆãŸå•é¡Œ'];
            deckCategoryTabs.innerHTML = categories.map(cat => `
                <button data-category="${cat}" class="category-tab px-3 py-2 text-sm sm:text-base sm:px-4 rounded-lg font-bold bg-gray-200 hover:bg-cyan-300 ${selectedCategory === cat ? 'active' : ''}">
                    ${cat}
                </button>
            `).join('');

            let decksToDisplay;
            if (selectedCategory === 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­') {
                decksToDisplay = allDecks.filter(deck => !deck.isDefault && (deck.category === 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­' || typeof deck.category === 'undefined'));
            } else {
                decksToDisplay = allDecks.filter(deck => deck.category === selectedCategory);
            }

            deckList.innerHTML = '';
            if (decksToDisplay.length === 0) {
                let emptyMessage = 'ã“ã®ã‚«ãƒ†ã‚´ãƒªã®ãƒ‡ãƒƒã‚­ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚';
                if (selectedCategory === 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­') {
                    emptyMessage = 'ã¾ã ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚<br>ã‚ãŸã‚‰ã—ã„ãƒ‡ãƒƒã‚­ã‚’ã¤ãã‚ã†ï¼';
                } else if (selectedCategory === 'ã¾ã¡ãŒãˆãŸå•é¡Œ') {
                    emptyMessage = 'ã¾ã ã¾ã¡ãŒãˆãŸå•é¡Œã®<br>ãƒ‡ãƒƒã‚­ã¯ãªã„ã‚ˆ';
                }
                deckList.innerHTML = `<p class="text-gray-500 text-base sm:text-xl">${emptyMessage}</p>`;
            } else {
                decksToDisplay.forEach(deck => {
                    const originalIndex = allDecks.indexOf(deck);
                    const deckEl = document.createElement('div');
                    deckEl.className = 'flex items-center gap-2 sm:gap-4';
                    deckEl.innerHTML = `
                        <button data-index="${originalIndex}" class="start-game-btn flex-grow bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-3 px-4 sm:py-4 sm:px-6 rounded-lg text-base sm:text-2xl btn-3d">${deck.name} (${deck.questions.length}ã‚‚ã‚“)</button>
                        <button data-index="${originalIndex}" class="edit-deck-btn bg-yellow-500 hover:bg-yellow-600 text-white font-bold p-3 sm:p-4 rounded-lg btn-3d text-lg sm:text-2xl">âœï¸</button>
                        ${!deck.isDefault ? `<button data-index="${originalIndex}" class="delete-deck-btn bg-red-500 hover:bg-red-600 text-white font-bold p-3 sm:p-4 rounded-lg btn-3d text-lg sm:text-2xl">ğŸ—‘ï¸</button>` : ''}
                    `;
                    deckList.appendChild(deckEl);
                });
            }
        }

        // --- Deck Editor ---
        let tempQuestions = [];
        function openDeckEditor(index = -1) {
            if (index === -1) { // New Deck
                deckNameInput.value = '';
                tempQuestions = [];
                currentDeckIndex = -1;
            } else { // Edit Deck
                const deck = allDecks[index];
                if (deck.isDefault) {
                    deckNameInput.value = deck.name + 'ã®ã‚³ãƒ”ãƒ¼';
                    currentDeckIndex = -1; // Treat as new deck
                } else {
                    deckNameInput.value = deck.name;
                    currentDeckIndex = index;
                }
                tempQuestions = JSON.parse(JSON.stringify(deck.questions));
            }
            renderQuestionsList();
            showScreen('deckEditor');
        }

        function renderQuestionsList() {
            questionsList.innerHTML = '';
            if(tempQuestions.length === 0) {
                questionsList.innerHTML = `<p class="text-gray-400 text-center p-4 text-base sm:text-lg">ã¾ã å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“</p>`;
            }
            tempQuestions.forEach((q, index) => {
                const qEl = document.createElement('div');
                qEl.className = 'bg-white p-2 sm:p-3 border rounded flex justify-between items-center text-sm sm:text-lg';
                qEl.innerHTML = `
                    <span class="truncate pr-2"><b>Q:</b> ${q.q} / <b>A:</b> ${q.a}</span>
                    <button data-index="${index}" class="delete-question-btn bg-red-500 text-white rounded px-2 py-1 text-xs sm:text-base">ã•ãã˜ã‚‡</button>
                `;
                questionsList.appendChild(qEl);
            });
        }

        // --- Game Setup ---
        function showSetupScreen(deckIndex) {
            currentDeckIndex = deckIndex;
            const deck = allDecks[deckIndex];
            setupTitle.textContent = `ã€${deck.name}ã€`;
            questionCountButtons.innerHTML = '';
            setupInfoArea.innerHTML = ''; // Clear info area

            if (deck.questions.length === 0) {
                questionCountButtons.innerHTML = `<p class="text-gray-500 col-span-2 lg:col-span-4 text-lg sm:text-xl">å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚<br>ãƒ‡ãƒƒã‚­ã‚’ç·¨é›†ã—ã¦ãã ã•ã„ã€‚</p>`;
            } else {
                const counts = [5, 10];
                // Always show 5 and 10 options
                counts.forEach(count => {
                     questionCountButtons.innerHTML += `<button data-questions="${count}" class="question-btn bg-cyan-400 hover:bg-cyan-500 text-white font-bold py-4 sm:py-5 px-4 rounded-lg text-lg sm:text-2xl btn-3d">${count}ä½“</button>`;
                });

                // Add practice mode button
                questionCountButtons.innerHTML += `<button id="practice-mode-btn" class="col-span-2 lg:col-span-4 bg-red-400 hover:bg-red-500 text-white font-bold py-4 sm:py-5 px-4 rounded-lg text-lg sm:text-2xl btn-3d">ã‚Œã‚“ã—ã‚…ã†ãƒ¢ãƒ¼ãƒ‰</button>`;

                // Add warning message
                setupInfoArea.innerHTML = `<p class="text-xs sm:text-sm text-gray-500 mt-4">ã‚‚ã‚“ã ã„ãŒå°‘ãªã„ã¨ãã¯ã€åŒã˜ã‚‚ã‚“ã ã„ãŒå‡ºã¡ã‚ƒã†ã‚ˆ</p>`;
            }
            showScreen('setup');
        }

        // --- Core Game Logic ---
        function startGame(numQuestions) {
            totalMonsters = numQuestions;
            defeatedMonsters = 0;
            mistakes = 0;
            buttonsDisabled = false;

            if (isPracticeMode) {
                correctBtn.classList.add('hidden');
                retryBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
                livesArea.classList.add('hidden');
                timerBar.parentElement.classList.add('hidden');
                stopTimer();
            } else {
                correctBtn.classList.remove('hidden');
                retryBtn.classList.remove('hidden');
                nextBtn.classList.add('hidden');
                livesArea.classList.remove('hidden');
                timerBar.parentElement.classList.remove('hidden');
            }

            let deckQuestions = [...allDecks[currentDeckIndex].questions];
            currentQuestions = []; // Reset the questions list

            if (deckQuestions.length > 0) {
                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®æ•°ã¨ãƒ©ã‚¤ãƒ•ãƒã‚¤ãƒ³ãƒˆï¼ˆé–“é•ãˆã‚‰ã‚Œã‚‹å›æ•°ï¼‰ã®åˆè¨ˆåˆ†ã®å•é¡Œã‚’ç”¨æ„ã—ã¾ã™ã€‚
                // ã“ã‚Œã«ã‚ˆã‚Šã€æ™‚é–“åˆ‡ã‚Œã§é–“é•ãˆã¦ã‚‚å¸¸ã«æ–°ã—ã„å•é¡ŒãŒå‡ºé¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
                const totalQuestionsToPrepare = numQuestions + MAX_MISTAKES;

                // åˆ©ç”¨å¯èƒ½ãªå•é¡Œã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã™ã€‚
                let shuffledDeck = [...deckQuestions].sort(() => 0.5 - Math.random());

                // å¿…è¦ãªå•é¡Œæ•°ãŒãƒ‡ãƒƒã‚­ã®å•é¡Œæ•°ã‚ˆã‚Šå°‘ãªã„ã‹ç­‰ã—ã„å ´åˆ
                if (totalQuestionsToPrepare <= shuffledDeck.length) {
                    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã‹ã‚‰å¿…è¦ãªæ•°ã ã‘å•é¡Œã‚’å–å¾—ã—ã¾ã™ã€‚
                    currentQuestions = shuffledDeck.slice(0, totalQuestionsToPrepare);
                } else {
                    // å¿…è¦ãªå•é¡Œæ•°ãŒãƒ‡ãƒƒã‚­ã®å•é¡Œæ•°ã‚ˆã‚Šå¤šã„å ´åˆ
                    // ã¾ãšã€ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã®ã™ã¹ã¦ã®å•é¡Œã‚’è¿½åŠ ã—ã¾ã™ã€‚
                    currentQuestions = [...shuffledDeck];

                    // ä¸è¶³ã—ã¦ã„ã‚‹å•é¡Œã®æ•°ã ã‘ã€å…ƒã®ãƒ‡ãƒƒã‚­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«è¿½åŠ ã—ã¾ã™ï¼ˆå•é¡ŒãŒé‡è¤‡ã—ã¾ã™ï¼‰ã€‚
                    const remainingQuestions = totalQuestionsToPrepare - shuffledDeck.length;
                    for (let i = 0; i < remainingQuestions; i++) {
                        const randomIndex = Math.floor(Math.random() * deckQuestions.length);
                        // å•é¡ŒãŒé‡è¤‡ã™ã‚‹å ´åˆã§ã‚‚ã€å„å•é¡ŒãŒç‹¬ç«‹ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãªã‚‹ã‚ˆã†ã«ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚
                        currentQuestions.push(JSON.parse(JSON.stringify(deckQuestions[randomIndex])));
                    }
                }
            }

            currentQuestions.forEach(q => q.result = null);
            currentQuestionIndex = 0;

            updateLives();
            showScreen('main');
            initializeCanvas();
            spawnMonster();
            displayQuestion();
            updateCounter();
        }

        function nextTurn() {
            buttonsDisabled = false;
            updateCounter();
            spawnMonster();
            displayQuestion();
        }

        function drawPracticeAnswer() {
            if (!canvasCtx || currentQuestionIndex >= currentQuestions.length) return;
            const answer = currentQuestions[currentQuestionIndex].a;
            const canvas = handwritingCanvas;
            canvasCtx.save();
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.15)';

            // Dynamically calculate font size to fit the canvas
            const maxFontSize = canvas.height * 0.7;
            let fontSize = maxFontSize;
            canvasCtx.font = `800 ${fontSize}px '${getComputedStyle(document.body).fontFamily}'`;

            while(canvasCtx.measureText(answer).width > canvas.width * 0.9) {
                fontSize--;
                canvasCtx.font = `800 ${fontSize}px '${getComputedStyle(document.body).fontFamily}'`;
            }

            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';
            canvasCtx.fillText(answer, canvas.width / 2, canvas.height / 2);
            canvasCtx.restore();
        }

        function displayQuestion() {
            clearCanvas();
            // ç”¨æ„ã—ãŸå•é¡Œãƒªã‚¹ãƒˆã‚’ã™ã¹ã¦ä½¿ã„åˆ‡ã£ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ˆäºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
            if (currentQuestionIndex >= currentQuestions.length) {
                 showClearScreen();
                return;
            }
            const qa = currentQuestions[currentQuestionIndex];
            questionDisplay.innerHTML = `<b>ã‚‚ã‚“ã ã„ï¼š</b> ${qa.q}`;
            buttonsDisabled = false;

            setTimeout(() => {
                if (isPracticeMode) {
                    initializeCanvas();
                    drawPracticeAnswer();
                }
            }, 100);

            if (!isPracticeMode) {
                startTimer();
            }
        }

        function spawnMonster() {
            monsterArea.innerHTML = '';
            let monster;
            // UPDATED: Monster size is now responsive and different for the boss
            let monsterSize;

            if (defeatedMonsters === totalMonsters - 1) {
                monster = BOSS_MONSTER;
                monsterTitle.textContent = `ã¤ã„ã«${monster.name}ãŒã‚ã‚‰ã‚ã‚ŒãŸï¼`;
                // Boss monster size
                monsterSize = 'w-36 h-36 sm:w-48 sm:h-48';
            } else {
                monster = MONSTERS[Math.floor(Math.random() * MONSTERS.length)];
                monsterTitle.textContent = `${monster.name}ãŒã‚ã‚‰ã‚ã‚ŒãŸï¼`;
                // Regular monster size
                monsterSize = 'w-32 h-32 sm:w-44 sm:h-44';
            }

            const monsterEl = document.createElement('div');
            monsterEl.className = `${monsterSize} animate-spawn flex items-center justify-center`;

            const img = document.createElement('img');
            img.src = monster.image;
            img.className = 'w-full h-full object-contain';
            img.alt = monster.name;

            monsterEl.appendChild(img);
            monsterArea.appendChild(monsterEl);
        }

        function updateCounter() {
            counter.textContent = `ã®ã“ã‚Š ${totalMonsters - defeatedMonsters} ä½“`;
        }

        function updateLives() {
            livesArea.innerHTML = 'â¤ï¸'.repeat(MAX_MISTAKES - mistakes) + 'ğŸ–¤'.repeat(mistakes);
        }

        function handleCorrect() {
            stopTimer();
            if (buttonsDisabled || currentQuestionIndex >= currentQuestions.length) return;
            buttonsDisabled = true;
            playSound('correct');
            currentQuestions[currentQuestionIndex].result = 'correct';
            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-defeat');
            monsterEl?.addEventListener('animationend', () => {
                defeatedMonsters++;
                currentQuestionIndex++;
                if (defeatedMonsters >= totalMonsters) {
                    showClearScreen();
                } else {
                    nextTurn();
                }
            }, { once: true });
        }

        function handleRetry() {
            if (buttonsDisabled) return;
            playSound('incorrect');
            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-shake');
            monsterEl?.addEventListener('animationend', () => {
                monsterEl.classList.remove('animate-shake');
            }, { once: true });
            clearCanvas();
        }

        function handleTimeUp() {
            stopTimer();
            if (buttonsDisabled || currentQuestionIndex >= currentQuestions.length) return;
            buttonsDisabled = true;
            playSound('incorrect');

            currentQuestions[currentQuestionIndex].result = 'incorrect';
            mistakes++;
            updateLives();

            if (mistakes >= MAX_MISTAKES) {
                setTimeout(showGameOverScreen, 500);
                return;
            }

            const monsterEl = monsterArea.querySelector('div');
            monsterEl?.classList.add('animate-shake');
            monsterEl?.addEventListener('animationend', () => {
                monsterEl.classList.remove('animate-shake');
                currentQuestionIndex++;
                // é–“é•ãˆãŸå ´åˆã¯ã€æ¬¡ã®å•é¡Œã‚’è¡¨ç¤ºã™ã‚‹ã ã‘
                displayQuestion();
            }, { once: true });
        }

        // --- Timer ---
        function startTimer() {
            stopTimer();
            let timeLeft = TIME_LIMIT;
            timerBar.style.transition = 'width 1s linear';
            const updateTimerDisplay = () => {
                const percentage = (timeLeft / TIME_LIMIT) * 100;
                timerBar.style.width = `${percentage}%`;
            };
            updateTimerDisplay();
            questionTimer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                if (timeLeft < 0) {
                    handleTimeUp();
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(questionTimer);
            questionTimer = null;
            timerBar.style.transition = 'none';
        }

        // --- Canvas Drawing ---
        function initializeCanvas() {
            if(!canvasCtx) canvasCtx = handwritingCanvas.getContext('2d');
            const { width, height } = handwritingCanvas.getBoundingClientRect();
            handwritingCanvas.width = width;
            handwritingCanvas.height = height;
            canvasCtx.strokeStyle = '#374151';
            canvasCtx.lineWidth = Math.max(2, width / 100); // Responsive line width
            canvasCtx.lineJoin = 'round';
            canvasCtx.lineCap = 'round';
            clearCanvas();

            if (isPracticeMode && !screens.main.classList.contains('hidden')) {
                drawPracticeAnswer();
            }
        }

        function clearCanvas() {
            if(canvasCtx) {
                canvasCtx.clearRect(0, 0, handwritingCanvas.width, handwritingCanvas.height);
                if (isPracticeMode && !screens.main.classList.contains('hidden')) {
                    drawPracticeAnswer();
                }
            }
        }

        function getCoords(e) {
            const rect = handwritingCanvas.getBoundingClientRect();
            const touch = e.touches && e.touches[0];
            return [
                (touch ? touch.clientX : e.clientX) - rect.left,
                (touch ? touch.clientY : e.clientY) - rect.top
            ];
        }

        function startDrawing(e) { e.preventDefault(); isDrawing = true; [lastX, lastY] = getCoords(e); }
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const [currentX, currentY] = getCoords(e);
            canvasCtx.beginPath();
            canvasCtx.moveTo(lastX, lastY);
            canvasCtx.lineTo(currentX, currentY);
            canvasCtx.stroke();
            [lastX, lastY] = [currentX, currentY];
        }
        function stopDrawing() { isDrawing = false; }

        // --- Result Screens ---
        function renderResults(containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = `<h3 class="text-xl sm:text-2xl font-bold mb-4 text-center">ã‚‚ã‚“ã ã„ã¨ã“ãŸãˆ</h3>`;
            const list = document.createElement('ul');
            list.className = 'space-y-3';
            const answeredQuestions = currentQuestions.filter(q => q.result);
            answeredQuestions.forEach(qa => {
                const item = document.createElement('li');
                item.className = 'border-b border-gray-400 pb-2 text-sm sm:text-lg';
                let resultHTML = qa.result === 'correct'
                    ? `<span class="font-bold text-green-500 mr-2">[ã›ã„ã‹ã„ï¼]</span>`
                    : `<span class="font-bold text-red-500 mr-2">[ãµã›ã„ã‹ã„â€¦]</span>`;
                item.innerHTML = `<div>${resultHTML}<b>Q:</b> ${qa.q}</div><div class="pl-6"><b class="${containerId.includes('clear') ? 'text-blue-600' : 'text-cyan-400'}">A:</b> ${qa.a}</div>`;
                list.appendChild(item);
            });
            if (answeredQuestions.length === 0) { list.innerHTML = `<p class="text-gray-500">ã‘ã£ã‹ãŒã‚ã‚Šã¾ã›ã‚“</p>`; }
            container.appendChild(list);
        }

        function showClearScreen() {
            stopTimer();
            showScreen('clear');

            const clearScreenTitle = document.querySelector('#clear-screen h1');
            const clearResultsArea = document.getElementById('clear-results-area');

            if (isPracticeMode) {
                clearScreenTitle.innerHTML = "ç·´ç¿’ãŠã‚ã‚Šï¼<br>ã‚ˆããŒã‚“ã°ã£ãŸã­ï¼";
                clearScreenTitle.className = 'text-3xl sm:text-6xl font-extrabold text-cyan-500 animate-celebrate';
                clearResultsArea.innerHTML = `<p class="text-center text-lg sm:text-xl text-gray-600 p-4">ãŸãã•ã‚“ç·´ç¿’ã—ã¦ã€<br>ã¤ãã¯æœ¬ç•ªã§ãŸãŸã‹ãŠã†ï¼</p>`;
            } else {
                clearScreenTitle.innerHTML = "ãœã‚“ã¶ ã‚„ã£ã¤ã‘ãŸï¼<br>ãŠã‚ã§ã¨ã†ï¼";
                clearScreenTitle.className = 'text-3xl sm:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 animate-celebrate';
                renderResults('clear-results-area');
            }

            const incorrectQuestions = currentQuestions.filter(q => q.result !== 'correct');
            const originalDeck = allDecks[currentDeckIndex];
            // ã¾ã¡ãŒãˆãŸå•é¡ŒãŒã‚ã‚Šã€ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰ã§ãªãã€ç¾åœ¨ã®ãƒ‡ãƒƒã‚­ãŒã€Œã¾ã¡ãŒãˆãŸå•é¡Œã€ãƒ‡ãƒƒã‚­ã§ãªã„å ´åˆã®ã¿ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (incorrectQuestions.length > 0 && !isPracticeMode && originalDeck.category !== 'ã¾ã¡ãŒãˆãŸå•é¡Œ') {
                const newDeckName = `${originalDeck.name}_ã¾ã¡ãŒãˆãŸå•é¡Œ`;
                const incorrectDeckExists = allDecks.some(deck => deck.name === newDeckName && !deck.isDefault);

                if (incorrectDeckExists) {
                    createIncorrectDeckClearBtn.textContent = `ã¾ã¡ãŒãˆãŸå•é¡Œã‚’ãƒ‡ãƒƒã‚­ã«è¿½åŠ `;
                } else {
                    createIncorrectDeckClearBtn.textContent = `ã¾ã¡ãŒãˆãŸå•é¡Œã§ãƒ‡ãƒƒã‚­ä½œæˆ`;
                }
                createIncorrectDeckClearBtn.disabled = false;
                createIncorrectDeckClearBtn.classList.remove('hidden');
            } else {
                createIncorrectDeckClearBtn.classList.add('hidden');
            }

            startConfetti();
        }

        function showGameOverScreen() {
            stopTimer();
            showScreen('gameover');
            renderResults('gameover-results-area');

            const incorrectQuestions = currentQuestions.filter(q => q.result !== 'correct');
            const originalDeck = allDecks[currentDeckIndex];
             // ã¾ã¡ãŒãˆãŸå•é¡ŒãŒã‚ã‚Šã€ç¾åœ¨ã®ãƒ‡ãƒƒã‚­ãŒã€Œã¾ã¡ãŒãˆãŸå•é¡Œã€ãƒ‡ãƒƒã‚­ã§ãªã„å ´åˆã®ã¿ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (incorrectQuestions.length > 0 && originalDeck.category !== 'ã¾ã¡ãŒãˆãŸå•é¡Œ') {
                const newDeckName = `${originalDeck.name}_ã¾ã¡ãŒãˆãŸå•é¡Œ`;
                const incorrectDeckExists = allDecks.some(deck => deck.name === newDeckName && !deck.isDefault);

                if (incorrectDeckExists) {
                    createIncorrectDeckGameoverBtn.textContent = `ã¾ã¡ãŒãˆãŸå•é¡Œã‚’ãƒ‡ãƒƒã‚­ã«è¿½åŠ `;
                } else {
                    createIncorrectDeckGameoverBtn.textContent = `ã¾ã¡ãŒãˆãŸå•é¡Œã§ãƒ‡ãƒƒã‚­ä½œæˆ`;
                }
                createIncorrectDeckGameoverBtn.disabled = false;
                createIncorrectDeckGameoverBtn.classList.remove('hidden');
            } else {
                createIncorrectDeckGameoverBtn.classList.add('hidden');
            }
        }

        function createIncorrectDeck(buttonElement) {
            const incorrectQuestionsRaw = currentQuestions.filter(q => q.result !== 'correct');

            if (incorrectQuestionsRaw.length === 0) return;

            const uniqueIncorrectQuestions = Array.from(new Map(incorrectQuestionsRaw.map(item =>
                [item.q, { q: item.q, a: item.a }]
            )).values());

            if (uniqueIncorrectQuestions.length === 0) return;

            const originalDeck = allDecks[currentDeckIndex];
            const newDeckName = `${originalDeck.name}_ã¾ã¡ãŒãˆãŸå•é¡Œ`;

            let incorrectDeck = allDecks.find(deck => deck.name === newDeckName && !deck.isDefault);

            if (incorrectDeck) {
                const existingQuestionsMap = new Map(incorrectDeck.questions.map(q => [q.q, q]));
                uniqueIncorrectQuestions.forEach(q => {
                    existingQuestionsMap.set(q.q, q);
                });
                incorrectDeck.questions = Array.from(existingQuestionsMap.values());
            } else {
                incorrectDeck = {
                    name: newDeckName,
                    questions: uniqueIncorrectQuestions,
                    isDefault: false,
                    category: 'ã¾ã¡ãŒãˆãŸå•é¡Œ' // ã‚«ãƒ†ã‚´ãƒªã‚’ã€Œã¾ã¡ãŒãˆãŸå•é¡Œã€ã«è¨­å®š
                };
                allDecks.push(incorrectDeck);
            }

            saveUserDecks();
            buttonElement.textContent = 'ä½œæˆã—ã¾ã—ãŸï¼';
            buttonElement.disabled = true;
        }


        // --- Event Listeners ---
        deckCategoryTabs.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.category) {
                selectedCategory = target.dataset.category;
                renderDeckSelectionScreen();
            }
        });

        deckList.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (!target) return;
            const index = parseInt(target.dataset.index);
            if (target.classList.contains('start-game-btn')) {
                if(allDecks[index].questions.length > 0) showSetupScreen(index);
                else alert('ã“ã®ãƒ‡ãƒƒã‚­ã«ã¯å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚ç·¨é›†ã—ã¦ãã ã•ã„ã€‚');
            } else if (target.classList.contains('edit-deck-btn')) {
                openDeckEditor(index);
            } else if (target.classList.contains('delete-deck-btn')) {
                if (confirm(`ã€Œ${allDecks[index].name}ã€ã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                    allDecks.splice(index, 1);
                    saveUserDecks();
                    renderDeckSelectionScreen();
                }
            }
        });

        newDeckBtn.addEventListener('click', () => openDeckEditor(-1));

        addQuestionBtn.addEventListener('click', () => {
            const q = newQuestionInput.value.trim();
            const a = newAnswerInput.value.trim();
            if (q && a) {
                tempQuestions.push({ q, a });
                newQuestionInput.value = '';
                newAnswerInput.value = '';
                renderQuestionsList();
                newQuestionInput.focus();
            }
        });

        questionsList.addEventListener('click', e => {
            if (e.target.classList.contains('delete-question-btn')) {
                const index = parseInt(e.target.dataset.index);
                tempQuestions.splice(index, 1);
                renderQuestionsList();
            }
        });

        saveDeckBtn.addEventListener('click', () => {
            const name = deckNameInput.value.trim();
            if (!name) { alert('ãƒ‡ãƒƒã‚­ã®ãªã¾ãˆã‚’ã„ã‚Œã¦ãã ã•ã„ã€‚'); return; }
            const newDeck = { name, questions: tempQuestions, isDefault: false, category: 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­' };
            if (currentDeckIndex === -1 || allDecks[currentDeckIndex]?.isDefault) {
                allDecks.push(newDeck);
            } else {
                allDecks[currentDeckIndex] = newDeck;
            }
            saveUserDecks();
            loadAndCombineDecks();
            selectedCategory = 'ã˜ã¶ã‚“ã®ãƒ‡ãƒƒã‚­';
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        });

        backToSelectionBtn.addEventListener('click', () => showScreen('deckSelection'));

        questionCountButtons.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (!target) return;

            if (target.id === 'practice-mode-btn') {
                isPracticeMode = true;
                const deck = allDecks[currentDeckIndex];
                const numQuestions = deck.questions.length >= 10 ? 10 : deck.questions.length;
                startGame(numQuestions);
            } else if (target.classList.contains('question-btn')) {
                isPracticeMode = false;
                startGame(parseInt(target.dataset.questions));
            }
        });

        backToDecksBtn.addEventListener('click', () => {
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        });

        correctBtn.addEventListener('click', handleCorrect);
        retryBtn.addEventListener('click', handleRetry);

        nextBtn.addEventListener('click', () => {
            if (buttonsDisabled) return;

            defeatedMonsters++;
            currentQuestionIndex++;

            if (defeatedMonsters >= totalMonsters) {
                showClearScreen();
            } else {
                nextTurn();
            }
        });

        document.querySelectorAll('.restart-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                renderDeckSelectionScreen();
                showScreen('deckSelection');
                stopConfetti();
            });
        });

        muteButton.addEventListener('click', () => {
            isMuted = !isMuted;
            soundOnIcon.classList.toggle('hidden', isMuted);
            soundOffIcon.classList.toggle('hidden', !isMuted);
        });

        // Canvas Event Listeners
        handwritingCanvas.addEventListener('mousedown', startDrawing);
        handwritingCanvas.addEventListener('mousemove', draw);
        handwritingCanvas.addEventListener('mouseup', stopDrawing);
        handwritingCanvas.addEventListener('mouseout', stopDrawing);
        handwritingCanvas.addEventListener('touchstart', startDrawing, { passive: false });
        handwritingCanvas.addEventListener('touchmove', draw, { passive: false });
        handwritingCanvas.addEventListener('touchend', stopDrawing);
        clearCanvasBtn.addEventListener('click', clearCanvas);
        window.addEventListener('resize', initializeCanvas);

        createIncorrectDeckClearBtn.addEventListener('click', () => createIncorrectDeck(createIncorrectDeckClearBtn));
        createIncorrectDeckGameoverBtn.addEventListener('click', () => createIncorrectDeck(createIncorrectDeckGameoverBtn));

        // --- App Initialization ---
        function initApp() {
            loadAndCombineDecks();
            renderDeckSelectionScreen();
            showScreen('deckSelection');
        }
        initApp();

        // --- Confetti Effect ---
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        let confettiParticles = []; let animationFrameId;
        function startConfetti(){if(!canvas)return;canvas.width=window.innerWidth;canvas.height=window.innerHeight;confettiParticles=[];for(let i=0;i<100;i++){confettiParticles.push(createParticle())}renderConfetti()}
        function stopConfetti(){if(animationFrameId)cancelAnimationFrame(animationFrameId)}
        function createParticle(){const colors=['#f9a8d4','#f472b6','#86efac','#34d399','#67e8f9','#22d3ee','#fcd34d','#fbbf24'];return{x:Math.random()*canvas.width,y:Math.random()*canvas.height-canvas.height,size:Math.random()*8+5,color:colors[Math.floor(Math.random()*colors.length)],speed:Math.random()*3+2,angle:Math.random()*360,spin:Math.random()<.5?-1:1}}
        function renderConfetti(){if(!canvas)return;ctx.clearRect(0,0,canvas.width,canvas.height);confettiParticles.forEach((p,i)=>{p.y+=p.speed;p.angle+=p.spin*5;ctx.save();ctx.fillStyle=p.color;ctx.translate(p.x+p.size/2,p.y+p.size/2);ctx.rotate(p.angle*Math.PI/180);ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size);ctx.restore();if(p.y>canvas.height){confettiParticles[i]=createParticle();confettiParticles[i].y=-10}});animationFrameId=requestAnimationFrame(renderConfetti)}
    });
    </script>
</body>
</html>
